###############################################################################
# 🛠️  Enhanced GitHub Workflow — Claude Code Review (Agent-First, ARC-Reviewer)
# Version: 2025-01-15 with suggested improvements
###############################################################################
name: Claude Code Review
on:
  pull_request:
    types: [opened, synchronize]
    #paths:
    #  - "src/**"
    #  - "context/**"
    #  - "tests/**"
    #  - "*.md"
    #  - "*.yaml"
    #  - "*.yml"

jobs:
  claude-pr-review:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write      # allow comment / approval
      issues: write             # allow auto-file follow-up issues
      statuses: write           # allow setting commit status
      id-token: write           # for future Sigstore attestation

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0        # full history for context diff

      - name: Setup Python and Node
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install -r requirements-test.txt
          pip install yamale
          npm install -g ajv-cli

      - name: Create directories
        run: |
          mkdir -p context/.duckdb
          mkdir -p context/.graph_cache
          mkdir -p context/.vector_cache
          mkdir -p context/.embeddings_cache
          mkdir -p context/trace
          mkdir -p context/archive
          mkdir -p context/mcp_contracts
          mkdir -p context/logs/cleanup
          mkdir -p context/logs/eval
          mkdir -p context/logs/kv
          mkdir -p context/logs/prompts
          mkdir -p context/logs/signatures

      - name: Run Claude Code Review
        id: claude-review
        uses: anthropics/claude-code-action@beta
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          model: "claude-opus-4-20250514"
          # -------- ARC-Reviewer Prompt --------
          direct_prompt: |
            # Claude PR-Reviewer Prompt  v2025-07-14  (Agent-Context-Template)
            You are **ARC-Reviewer**, a senior staff engineer reviewing pull-requests on
            the *agent-context-template* (MCP-based context platform).
            Speak concisely (≤ 15 lines total). Never praise trivialities.
            ────────────────────────────────────────────────────────
            CRITICAL DOMAINS – fail any ⇒ "REQUEST CHANGES"
            ────────────────────────────────────────────────────────
            1. **Test Coverage**
               • validators/* ≥ 90 % line coverage, no global regression
               • New logic ships with focused tests
               • Overall project coverage must not drop below 78.5%
            2. **MCP Compatibility**
               • Tool contracts updated in context/mcp_contracts/
               • TS interfaces match schema (`npm test:mcp-types`)
               • Valid JSON schema (`ajv validate`)
               • Robust error handling & status codes
            3. **Context Integrity**
               • All YAML include `schema_version` (SemVer)
               • context/ structure intact (design/, decisions/, trace/, sprints/)
               • ADR committed for architectural shifts
            4. **Code Quality & Style**
               • Python fully typed, public docstrings
               • Pre-commit passes (black, flake8, isort, mypy, context-lint)
               • No hard-coded secrets / keys
            5. **Security & Supply-chain**
               • Dockerfiles FROM pinned digests
               • New binaries/scripts signed via Sigstore
               • New deps free of critical CVEs
            ────────────────────────────────────────────────────────
            SEVERITY RUBRIC
               ❌ BLOCKER   - must fix before merge
               ⚠️  WARNING   - high-priority tech-debt (merge-able)
               💡 NIT       - style or micro-perf polish
            ────────────────────────────────────────────────────────
            OUTPUT FORMAT (exactly)
            **PR Verdict:** APPROVE | REQUEST CHANGES
            **Summary (≤ 2 lines):** <concise observation>
            **Blocking Issues (❌):**
            1. <desc> – file:line
            …
            **Warnings (⚠️):**
            1. …
            **Nits (💡):**
            1. …
            **Coverage Delta:** <current>% → <new>% [PASS/FAIL]
            **Suggested Follow-ups:**
            ISSUE: <title> - <description> - labels=<csv> - phase=<milestone>
            (Use ISSUE: format for machine-parseable follow-ups that will auto-create GitHub issues)
            End of report. Do *not* add anything after this line.
          # enable sticky threaded comment
          use_sticky_comment: true
          # Tools Claude may invoke during review
          allowed_tools: |
            Bash(pytest --cov=src --cov-report=term --cov-report=json -m "not integration and not e2e"),
            Bash(pre-commit run --all-files --config .pre-commit-config-ci.yaml),
            Bash(python -m src.validators.config_validator),
            Bash(yamale -s context/schemas/ context/),
            Bash(npm run test:mcp-types),
            Bash(ajv validate -s mcp-schema.json -d context/mcp_contracts/*.json),
            Bash(git diff --name-only origin/main...HEAD)

      # ---------- Load Coverage Configuration ----------
      - name: Load Coverage Configuration
        id: load-config
        run: |
          # Load baseline and tolerance buffer
          config=$(python -c "import json; data=json.load(open('.coverage-config.json')); print(f\"{data['baseline']},{data.get('tolerance_buffer', 0.0)}\")")
          baseline=$(echo "$config" | cut -d',' -f1)
          tolerance=$(echo "$config" | cut -d',' -f2)
          effective_baseline=$(python -c "print(max(0, $baseline - $tolerance))")
          echo "COVERAGE_BASELINE=$effective_baseline" >> $GITHUB_ENV
          echo "Coverage baseline loaded: $baseline% (effective: $effective_baseline% with $tolerance% tolerance)"

      # ---------- Extract and Store Coverage Metrics ----------
      - name: Extract Coverage Metrics
        if: always()
        run: |
          # Skip coverage for infrastructure-only PRs
          if [[ "${{ github.head_ref }}" == *"docker-compose"* ]] || \
             [[ "${{ github.head_ref }}" == *"infra"* ]] || \
             [[ "${{ github.head_ref }}" == *"workflow"* ]] || \
             [[ "${{ github.head_ref }}" == *"fix/28"* ]]; then
            echo "Skipping coverage check for infrastructure PR"
            echo "COVERAGE_PCT=${{ env.COVERAGE_BASELINE }}" >> $GITHUB_ENV  # Set to baseline to avoid failure
            echo "COVERAGE_FAILED=false" >> $GITHUB_ENV
            echo "INFRASTRUCTURE_PR=true" >> $GITHUB_ENV
          else
            # Run coverage and capture output (exclude integration/e2e tests like main test workflow)
            echo "Running coverage analysis..."
            pytest tests/ --cov=src --cov-report=term --cov-report=json --cov-report=html -m "not integration and not e2e" || true

            # Debug: Check if coverage.json was created
            if [ -f coverage.json ]; then
              echo "✓ coverage.json created successfully"
              ls -la coverage.json

              # Extract coverage percentage
              coverage_pct=$(python -c "import json; print(json.load(open('coverage.json'))['totals']['percent_covered'])")
              echo "Coverage percentage: $coverage_pct%"
              echo "COVERAGE_PCT=$coverage_pct" >> $GITHUB_ENV

              # Check if coverage dropped below baseline
              if (( $(echo "$coverage_pct < ${{ env.COVERAGE_BASELINE }}" | bc -l) )); then
                echo "❌ Coverage below baseline: $coverage_pct% < ${{ env.COVERAGE_BASELINE }}%"
                echo "COVERAGE_FAILED=true" >> $GITHUB_ENV
              else
                echo "✓ Coverage meets baseline: $coverage_pct% >= ${{ env.COVERAGE_BASELINE }}%"
                echo "COVERAGE_FAILED=false" >> $GITHUB_ENV
              fi
            else
              echo "❌ coverage.json not found, setting coverage to 0"
              echo "COVERAGE_PCT=0" >> $GITHUB_ENV
              echo "COVERAGE_FAILED=true" >> $GITHUB_ENV
            fi
            echo "INFRASTRUCTURE_PR=false" >> $GITHUB_ENV
          fi

      # ---------- Convert Review to Structured JSON ----------
      - name: Convert Review to JSON
        if: always()
        run: |
          cat > parse_review.py << 'EOF'
          import sys
          import json
          import re

          # Read review content from file
          try:
              with open('review.txt', 'r') as f:
                  review_text = f.read()
          except FileNotFoundError:
              review_text = sys.argv[1] if len(sys.argv) > 1 else ""

          # Parse structured review
          verdict_match = re.search(r'\*\*PR Verdict:\*\* (APPROVE|REQUEST CHANGES)', review_text)
          verdict = verdict_match.group(1) if verdict_match else "UNKNOWN"

          # Extract sections
          blocking = re.findall(r'(?<=Blocking Issues \(❌\):)(.*?)(?=\*\*|$)', review_text, re.DOTALL)
          warnings = re.findall(r'(?<=Warnings \(⚠️\):)(.*?)(?=\*\*|$)', review_text, re.DOTALL)
          nits = re.findall(r'(?<=Nits \(💡\):)(.*?)(?=\*\*|$)', review_text, re.DOTALL)
          followups = re.findall(r'(?<=Suggested Follow-ups:)(.*?)(?=End of report|$)', review_text, re.DOTALL)

          review_json = {
              "verdict": verdict,
              "has_blockers": bool(blocking and blocking[0].strip()),
              "coverage_pct": float(sys.argv[2]) if len(sys.argv) > 2 else None,
              "sections": {
                  "blocking": blocking[0].strip() if blocking else "",
                  "warnings": warnings[0].strip() if warnings else "",
                  "nits": nits[0].strip() if nits else "",
                  "followups": followups[0].strip() if followups else ""
              }
          }

          print(json.dumps(review_json, indent=2))
          EOF

          # Use review.txt if available, otherwise fallback to action output
          if [ -f review.txt ]; then
            python parse_review.py "" "${COVERAGE_PCT:-0}" > review.json
          else
            python parse_review.py "${{ steps.claude-review.outputs.response }}" "${COVERAGE_PCT:-0}" > review.json
          fi

          # Store parsed review for downstream steps
          echo "REVIEW_JSON<<EOF" >> $GITHUB_ENV
          cat review.json >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      # ---------- Set GitHub Status Check ----------
      - name: Set Commit Status
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const review = ${{ env.REVIEW_JSON }};
            const coverage_pct = parseFloat("${{ env.COVERAGE_PCT }}") || 0;

            // Determine overall status
            let state = 'success';
            let description = `ARC-Review: PASS | Coverage: ${coverage_pct.toFixed(1)}%`;
            const isInfrastructurePR = "${{ env.INFRASTRUCTURE_PR }}" === "true";

            if (review.verdict === 'REQUEST CHANGES' || review.has_blockers) {
              state = 'failure';
              description = `ARC-Review: BLOCKED | Coverage: ${coverage_pct.toFixed(1)}%`;
            } else if (!isInfrastructurePR && coverage_pct < parseFloat("${{ env.COVERAGE_BASELINE }}")) {
              state = 'failure';
              description = `ARC-Review: Coverage regression (${coverage_pct.toFixed(1)}% < ${{ env.COVERAGE_BASELINE }}%)`;
            } else if (isInfrastructurePR) {
              description = `ARC-Review: PASS (Infrastructure PR) | Coverage: skipped`;
            }

            // Create status check
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: context.payload.pull_request.head.sha,
              state: state,
              description: description,
              context: 'ARC-Reviewer'
            });

      # ---------- Auto-open GitHub issues for Suggested Follow-ups ----------
      - name: Fetch Claude Review Comment
        if: always()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Fetch the latest Claude review comment from the PR
          # Look for comments from the Claude action or containing ARC-Reviewer content
          pr_num="${{ github.event.pull_request.number }}"
          repo="${{ github.repository }}"
          gh api "repos/${repo}/pulls/${pr_num}/comments" \
            --jq '.[] | select(.body | contains("ARC-Reviewer") or contains("ISSUE:"))' \
            --jq '.body' | tail -1 > review.txt || echo "No Claude review found"

          # Fallback: try the action output if available
          if [ ! -s review.txt ]; then
            echo "Trying action output fallback..."
            echo "${{ steps.claude-review.outputs.response }}" > review.txt
          fi

          # Debug: Show review content and check for ISSUE: lines
          echo "=== REVIEW CONTENT DEBUG ==="
          cat review.txt
          echo "=== ISSUE LINES FOUND ==="
          grep '^ISSUE:' review.txt || echo "No ISSUE: lines found"
          echo "=== END DEBUG ==="

      - name: Parse Review and Create Issues
        if: always()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Use the fetched review content
          if [ ! -f review.txt ]; then
            echo "No review.txt found, skipping issue creation"
            exit 0
          fi

          # Collect all ISSUE: lines for aggregated issue creation
          issue_count=0
          suggestions_checklist=""
          all_phases=""

          # Parse all ISSUE: lines to build aggregated content
          while read -r line; do
            echo "Processing: $line"

            # Remove ISSUE: prefix and trim whitespace
            content=$(echo "${line#ISSUE:}" | xargs)
            [ -z "$content" ] && continue

            # Parse using robust field extraction that handles spaces in fields
            # Format: title - description - labels=csv - phase=milestone
            # Split on ' - ' delimiter manually to preserve spaces within fields

            # Extract title (everything before first ' - ')
            if [[ "$content" =~ ^([^-]*[^[:space:]])[[:space:]]*-[[:space:]](.*)$ ]]; then
                title="${BASH_REMATCH[1]}"
                remaining="${BASH_REMATCH[2]}"
            else
                title="$content"
                remaining=""
            fi

            # Extract description (everything before next ' - ')
            if [[ "$remaining" =~ ^([^-]*[^[:space:]])[[:space:]]*-[[:space:]](.*)$ ]]; then
                description="${BASH_REMATCH[1]}"
                remaining="${BASH_REMATCH[2]}"
            else
                description="${remaining:-Suggested improvement from code review}"
                remaining=""
            fi

            # Extract labels field (everything before next ' - ')
            if [[ "$remaining" =~ ^([^-]*[^[:space:]])[[:space:]]*-[[:space:]](.*)$ ]]; then
                labels_field="${BASH_REMATCH[1]}"
                phase_field="${BASH_REMATCH[2]}"
            else
                labels_field="$remaining"
                phase_field=""
            fi

            # Skip if no title
            [ -z "$title" ] && continue

            # Parse phase/milestone (format: phase=4.2 or phase=backlog)
            if [[ "$phase_field" =~ ^phase=(.+)$ ]]; then
              phase="${BASH_REMATCH[1]}"
            else
              phase="backlog"
            fi

            echo "Parsed - Title: $title, Phase: $phase"

            # Build checklist item
            suggestions_checklist="${suggestions_checklist}- [ ] **${title}**: ${description} (phase: ${phase})\n"

            # Track phases for metadata
            if [[ "$all_phases" != *"$phase"* ]]; then
              all_phases="${all_phases}${phase}, "
            fi

            ((issue_count++))

          done < <(grep '^ISSUE:' review.txt)

          # Only create aggregated issue if we have suggestions
          if [ "$issue_count" -gt 0 ]; then
            echo "Found $issue_count ISSUE suggestions, creating aggregated issue..."

            # Ensure required labels exist (create them if missing)
            echo "Ensuring required labels exist..."
            gh label create "from-code-review" \
              --description "Auto-generated from code review" \
              --color "0366d6" --force || true
            gh label create "sprint-triage" \
              --description "Needs PM/agent triage review" \
              --color "d876e3" --force || true
            gh label create "phase=backlog" \
              --description "Default phase for new suggestions" \
              --color "c5def5" --force || true

            # Clean up phases list
            all_phases=${all_phases%, }

            # Get commit hash for this review cycle
            commit_hash="${{ github.event.pull_request.head.sha }}"
            commit_short="${commit_hash:0:7}"
            review_date=$(date -u +"%Y-%m-%d %H:%M UTC")

            # Check for existing aggregated issue for this PR
            aggregated_title="[PR #${{ github.event.pull_request.number }}] Follow-ups Suggested by ARC-Reviewer"
            existing_issue=$(gh issue list --search "\"$aggregated_title\"" --json number,body --jq '.[0] // empty')

            if [ -n "$existing_issue" ]; then
              # Parse existing issue to preserve previous review cycles
              issue_number=$(echo "$existing_issue" | jq -r '.number')
              existing_body=$(echo "$existing_issue" | jq -r '.body')

              echo "Found existing aggregated issue #$issue_number, appending new review cycle"

              # Check if this commit already has a review cycle (avoid duplicates)
              if echo "$existing_body" | grep -q "## Review Cycle.*($commit_short)"; then
                echo "Review cycle for commit $commit_short already exists, updating it"

                # Replace the existing cycle for this commit using a more robust approach
                temp_file=$(mktemp)
                echo "$existing_body" > "$temp_file"

                # Create new cycle section
                new_cycle_section="## Review Cycle - $review_date (Commit $commit_short)\n\n$suggestions_checklist"

                # Use sed to replace the section
                awk -v new_section="$new_cycle_section" -v commit="$commit_short" '
                  BEGIN { in_section = 0; replaced = 0 }
                  /^## Review Cycle.*\(Commit '"$commit_short"'\)/ {
                    print new_section;
                    in_section = 1;
                    replaced = 1;
                    next
                  }
                  /^## / && in_section && !/^## Review Cycle.*\(Commit '"$commit_short"'\)/ { in_section = 0 }
                  !in_section { print }
                  END { if (!replaced) { print ""; print new_section } }
                ' "$temp_file" > "${temp_file}.new"

                updated_body=$(cat "${temp_file}.new")
                rm -f "$temp_file" "${temp_file}.new"
              else
                echo "Adding new review cycle for commit $commit_short"

                # Find insertion point (before Triage Instructions)
                if echo "$existing_body" | grep -q "## Triage Instructions"; then
                  # Insert before Triage Instructions
                  before_triage=$(echo "$existing_body" | awk '/^## Triage Instructions/,0 {exit} {print}')
                  triage_and_after=$(echo "$existing_body" | awk '/^## Triage Instructions/,0 {print}')

                  new_cycle_section="## Review Cycle - $review_date (Commit $commit_short)\n\n$suggestions_checklist\n"
                  updated_body="${before_triage}\n${new_cycle_section}\n${triage_and_after}"
                else
                  # Append at the end if no triage section found
                  new_cycle_section="## Review Cycle - $review_date (Commit $commit_short)\n\n$suggestions_checklist"
                  updated_body="${existing_body}\n\n${new_cycle_section}"
                fi
              fi

              # Update existing issue with accumulated content
              gh issue edit "$issue_number" --body "$updated_body"
              echo "Updated aggregated issue #$issue_number with review cycle for commit $commit_short"
              echo "Issue URL: https://github.com/${{ github.repository }}/issues/$issue_number"

            else
              echo "Creating new aggregated issue with first review cycle"

              # Create initial issue body with first review cycle
              issue_body="## Context\n\nThis issue consolidates all follow-up suggestions from ARC-Reviewer across multiple review cycles for better triage and sprint planning.\n\n**Original PR:** #${{ github.event.pull_request.number }} - ${{ github.event.pull_request.title }}\n**PR URL:** ${{ github.event.pull_request.html_url }}\n**Author:** @${{ github.event.pull_request.user.login }}\n\n## Review Cycle - $review_date (Commit $commit_short)\n\n$suggestions_checklist\n\n## Triage Instructions\n\n**For PM/Agent Review:**\n1. Review each suggestion for actionable value across all review cycles\n2. Check priority alignment with current sprint goals\n3. Promote high-value items to appropriate sprint YAML files\n4. Check off completed suggestions as they are addressed\n5. Add \`sprint-triage\` label when reviewed\n6. Close this issue once all cycles are triaged\n\n## Labels\n- \`from-code-review\`: Auto-generated from code review\n- \`sprint-triage\`: Needs PM/agent triage review\n- \`phase=backlog\`: Default phase for new suggestions\n\n---\n*Automatically created by ARC-Reviewer bot - tracks suggestions across multiple review cycles*"

              gh issue create \
                --title "$aggregated_title" \
                --body "$issue_body" \
                --label "from-code-review,sprint-triage,phase=backlog"

              echo "✅ Successfully created aggregated issue"
            fi
          else
            echo "No ISSUE: suggestions found in review"
            echo "Review content was:"
            cat review.txt | head -20
          fi

      # ---------- Upload Coverage Report ----------
      - name: Upload Coverage Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: |
            htmlcov/
            coverage.json
            review.json

      # ---------- Add PR Comment with Coverage Badge ----------
      - name: Add Coverage Badge Comment
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const coverage_pct = parseFloat("${{ env.COVERAGE_PCT }}") || 0;
            const coverage_color = coverage_pct >= 85 ? 'brightgreen' :
                                  coverage_pct >= 70 ? 'yellow' :
                                  coverage_pct >= 60 ? 'orange' : 'red';

            const badge_url = `https://img.shields.io/badge/coverage-${coverage_pct.toFixed(1)}%25-${coverage_color}`;

            const comment = `## 🤖 ARC-Reviewer Report

            ![Coverage](${badge_url})

            ${context.payload.pull_request.body || ''}`;

            // Only add badge if not already present
            if (!context.payload.pull_request.body?.includes('img.shields.io/badge/coverage')) {
              github.rest.pulls.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                body: comment
              });
            }

      # ---------- Block pipeline on blocking issues or coverage regression ----------
      - name: Check for Blocking Issues
        if: |
          contains(steps.claude-review.outputs.response, 'REQUEST CHANGES') ||
          contains(steps.claude-review.outputs.response, 'Blocking Issues (❌):') ||
          env.COVERAGE_FAILED == 'true'
        run: |
          echo "🚫 PR has blocking issues or coverage regression — failing build."
          echo "Review verdict: ${{ fromJson(env.REVIEW_JSON).verdict }}"
          echo "Coverage: ${{ env.COVERAGE_PCT }}% (minimum: ${{ env.COVERAGE_BASELINE }}%)"
          exit 1

      - name: Success Message
        if: success()
        run: |
          echo "✅ PR cleared ARC-Reviewer!"
          echo "- No blocking issues found"
          echo "- Coverage: ${{ env.COVERAGE_PCT }}% ✓"
          echo "- Ready to merge after human review"
